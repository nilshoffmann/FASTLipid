/**
 * AccAscComposition.java
 *
 * 2012.10.03
 *
 * This file is part of the CheMet library
 *
 * The CheMet library is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * CheMet is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with CheMet. If not, see
 * <http://www.gnu.org/licenses/>.
 */
package uk.ac.ebi.lipidhome.fastlipid.composition;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

/**
 * @name AccAscComposition @date 2012.10.03
 *
 * @version $Rev$ : Last Changed $Date$
 * @author pmoreno
 * @author $Author$ (this version) 
 * @brief Implementation of the accelerated ascendent composition generator as described
 * in "Generating all partitions: a comparison of two encodings" J. Kelleher and B. O'Sullivan, 
 * http://arxiv.org/abs/0909.2331. 
 * 
 * A composition is the partition of an integer into different integers, that summed together make up the original integer.
 * The composition is not fixed width, and can have different number of integers participating. Each different array of 
 * integers generated by the composition is unique and ordered (in the case of this implementation, in ascending order).
 * 
 * This implementation is a modification of the one presented in the paper, which relies in Python generators. The idea
 * of resuming code execution at the previous step left is emulated in a procedural manner.
 * 
 * The composition for 3 would be:
 * [1, 1, 1]
 * [1, 2]
 * [3]
 * 
 *
 */
public class AccAscComposition implements Iterator<List<Integer>> {

    private int n;
    int[] a; // keeps the state
    int k;  // k is an index 
    int y;
    List<Integer> next;

    /**
     * Constructor which receives the number to calculate the composition for. 
     * 
     * @param numToDoCompositionFor 
     */
    public AccAscComposition(Integer numToDoCompositionFor) {
        this.n = numToDoCompositionFor;
        /**
         * Initial part of the algorithm.
         */
        a = new int[n]; // array of n zeros
        for (int i = 0; i < n; i++) {
            a[i] = 0;
        }
        k = 1;
        y = n - 1;
    }
    
    boolean endedInReturnA = false;
    boolean endedInReturnB = true;
    private int xTempStore;
    private int lTempStore;

    /**
     * Returns whether the composition has a next element to return. The computation is carried out here.
     * 
     * @return true if the composition has a next element to return. 
     */
    public boolean hasNext() {
        /**
         * If n is zero there is no composition to make. This must be handled externally for compositions for double bonds
         * when zero double bonds are used.
         */
        if (n == 0) {
            return false;
        }

        /**
         * Main loop of the algorithm. An entrance is acceptable with k==0 iff the process stopped after a return of 
         * section A.
         */
        loopK:
        while (k != 0 || endedInReturnA) {
            int x;
            int l;
            if (endedInReturnB) {
                /**
                 * Executed only when the process is started, when there is a previous return from section B,
                 * or when the loopK went through without any returns from Section A.
                 */
                x = a[k - 1] + 1;          // value in k-1 index + 1
                k -= 1;
                while (2 * x <= y) {
                    a[k] = x;
                    y -= x;
                    k += 1;
                }
                l = k + 1;
            } else {
                /**
                 * Executed if section A returned before, just to restore the state of x and l, which are local variables
                 * to the loop.
                 */
                x = xTempStore;
                l = lTempStore;
            }
            while (x <= y) {
                if (endedInReturnB) {
                    /**
                     * Section A
                     */
                    a[k] = x;
                    a[l] = y;
                    if (checkedYield(a, 0, k + 2)) { //a.subList(0, k + 2) // a[:k + 2]
                        next = getArrayPart(a, 0, k + 2);
                        endedInReturnA = true;
                        endedInReturnB = false;
                        xTempStore = x;
                        lTempStore = l;
                        return true; // return A
                    }
                    /**
                     * Section A
                     */
                }
                /**
                 * The process resumes here if section A was the last to be executed and returned.
                 */
                x += 1;
                y -= 1;
                xTempStore = x;
                lTempStore = l;
                if (x <= y) {
                    endedInReturnB = true;
                    endedInReturnA = false;
                }

            }
            /**
             * Section B
             */
            a[k] = x + y;
            y = x + y - 1;
            if (checkedYield(a, 0, k + 1)) { // a.subList(0, k + 1) // a[:k + 1]
                next = getArrayPart(a, 0, k + 1);
                endedInReturnA = false;
                endedInReturnB = true;
                return true;
            }
            endedInReturnB = true;
            endedInReturnA = false;
            /**
             * Section B
             */
        }
        return false;
    }

    /**
     * Returns the next element of the composition.
     * 
     * @return {@link List} of {@link Integer} with the next element of the composition. 
     */
    public List<Integer> next() {
        return next;
    }

    /**
     * Currently not implemented, produced a runtime exception (UnsupportedOperation).
     */
    public void remove() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    /**
     * For subclasses of this composition maker that have rules regarding the elements of the composition that should be
     * outputted, those rules should be implemented here. The method should check whether the portion of the result array,
     * which holds the entire computation, from "indexFrom" to "indexTo" (non inclusive) complies with the rules defined.
     * 
     * @param result
     * @param indexFrom
     * @param indexTo
     * @return true if the portion of the result should be returned later.
     */
    boolean checkedYield(int[] result, int indexFrom, int indexTo) {
        return true;
    }

    /**
     * For subclasses of this composition maker that have rules regarding the elements of the composition that should be
     * outputted, the output generated should be implemented here. The output should be limited to the data present in the 
     * result array from "indexFrom" to "indexTo" (non inclusive).
     * 
     * @param result
     * @param indexFrom
     * @param indexTo
     * @return the portion of the result as a {@link List} of {@link Integer}s.
     */
    List<Integer> getArrayPart(int[] result, int indexFrom, int indexTo) {
        List<Integer> toRet = new ArrayList<Integer>(indexTo - indexFrom);
        for (int count : Arrays.copyOfRange(result, indexFrom, indexTo)) {
            toRet.add(count);
        }
        return toRet;
    }
}
